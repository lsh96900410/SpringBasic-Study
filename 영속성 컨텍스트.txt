[ 영속성 관리 ]

1. EntityManager란 ?
	
엔티티 CRUD 등 엔티티와 관련된 모든 일을 처리한다.
Thread-safe 하지 않기때문에 여러 쓰레드에서 사용을 하게되면 동시성 문제가 발생한다.
보통 트랜잭션을 시작할 때 데이터베이스와의 커넥션을 획득한다.
영속성 컨텍스트에 엔티티를 보관하고 관리

2. 영속성 컨텍스트 (Persistence context)란 ?

JPA 를 이해하는데 가장 중요.
엔티티를 영구 저장하는 환경 -> 엔티티를 저장 or 조회하면 엔티티를 보관하고 관리한다.
여러 엔티티매니저가 하나의 영속성 컨텍스트에 접근 가능하지만, 엔티티매니저와 보통 1:1 관계로 생성된다.
<플러시> 
1. 엔티티 매니저의 flush() 메쏘드 직접 호출
2. 트랜잭션 커밋 시 자동 호출
3. JPA 쿼리 실행시 자동 호출

<엔티티의 상태>	
 1. 비영속 : 영속성 컨텍스트와 전혀 관계없는 상태.
		순수한 객체 상태 
 2. 영속  :  영속성 컨텍스트에 저장되어 관리를 받는 상태.
 3. 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태. 
 4. 삭제  : 영속성 컨텍스트에서 삭제된 상태.

 < 영속성 컨텍스트의 특징 > 
 1. 영속 상태는 식별자 값이 반드시 존재해야한다. -> 엔티티 구별 
 2. 1차 캐시, 동일성 보장, 쓰기 지연, 변경 감지, 지연 로딩 등의 기능을 제공한다.
 
1차 캐시 : 영속성 컨텍스트 내부의 캐시 공간 [ db 접근 전] , key : pk값 value : 엔티티 인스턴스 
	엔티티 매니저로 조회하거나 변경하는 모든 엔티티는 1차 캐시에 저장
	트랜잭션을 커밋하거나 플러시를 호출하면, 1차 캐시에 있는 벼경 내역을 db에 동기화
		ex)find 작업시 1차적으로 1차 캐시를 조회하고 없다면, db에 접근을 한다. --> db 조회 횟수를 줄여 성능상 이점 
		그렇기에, find() 작업을 반복적으로해도 1차캐시에 존재하는 같은 엔티티 인스턴스를 반환하여 동일성을 보장.
	일반적으로 트랜잭션의 시작과 끝과 같은 라이프 사이클을 가질 수 있다.


쓰기 지연 : db에 쿼리문을 날리는 시점은 커밋하기 전에만 모든 작업의 쿼리문을 정상적으로 날리기만하면된다.
	    그렇기에, 엔티티 매니저는 트랜잭션 커밋 직전까지 sql 저장소에 쿼리문을 모아둔다. => 성능 최적화.
		
변경 감지 : update 쿼리를 네이티브 쿼리로 작성을 하게되면, 직,간접적으로 비지니스로직이 sql에 의존하게 됨. 
	    jpa에서는 엔티티의 변경사항을 db에 자동으로 반영하는 기능 
	    엔티티의 최초 상태를 복사하여 저장해둔 스냅샷과 플러시 시점의 엔티티를 비교하여 변경된 엔티티를 찾음.
변경 감지 기능은 모든 필드를 사용하기에 데이터 전송량이 증가하는 단점이 있지만, 
수정쿼리가 항상 같아 애플리케이션 로딩 시점에 쿼리를 미리 생성해두고 재사용할 수있고, db는 이전에 파싱된 쿼리를 재사용 가능

단, 필드가 너무 많거나 수정된 데이터만 사용하고싶다면 @DynamicUpdate 어노테이션 사용 가능.
[Tip]
컬럼이 대략 30개 이상이되면 동적 수정 쿼리가 더 빠르다고한다.

지연 로딩 (fetchtype.lazy): 실제 객체 대신 프록시 객체를로딩해두고 해당 객체를 실제 사용할 때 영속성 컨텍스트를 통해 데이터를 불러오는 방법.
	   --> 준영속 상태에서 지연 로딩을 하게되면 영속성컨텍스트가 관리하지않기에 문제가 발생함. 
	    쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하는 것이 아니라 필요할 때 쿼리를 날려 데이터를 조회
vs 즉시 로딩(fetchtype.Eager) : 조회할때 쿼리를 보내 연관된 모든 데이터를 가져옴  









